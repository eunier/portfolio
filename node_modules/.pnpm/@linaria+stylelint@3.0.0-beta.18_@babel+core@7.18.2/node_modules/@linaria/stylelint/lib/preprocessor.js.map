{"version":3,"sources":["../src/preprocessor.ts"],"names":["preprocessor","errors","cache","offsets","code","input","filename","result","undefined","e","rules","replacements","generatedLineNumber","cssText","Object","values","map","rule","ruleText","className","start","push","generated","line","column","original","name","displayName","split","length","join","reverse","console","log","error","sourceMap","warnings","warning","offset","find","o","prefix","message","startsWith","replace","loc","l","includes","Number","trim","errored","text","severity","forEach","w","end","module","exports"],"mappings":"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","sourcesContent":["import stripAnsi from 'strip-ansi';\nimport { transform } from '@linaria/babel-preset';\nimport type { Replacement } from '@linaria/babel-preset';\n\ntype Errors = {\n  [key: string]:\n    | {\n        name?: string;\n        code?: string;\n        message: string;\n        pos?: number;\n        loc?: {\n          line: number;\n          column: number;\n        };\n      }\n    | null\n    | undefined;\n};\n\ntype Cache = {\n  [key: string]: Replacement[] | null | undefined;\n};\n\ntype Warning = {\n  rule?: string;\n  text: string;\n  severity: 'error' | 'warning';\n  line: number;\n  column: number;\n};\n\ntype LintResult = {\n  errored: boolean;\n  warnings: Warning[];\n};\n\ninterface IPosition {\n  line: number;\n  column: number;\n}\n\ninterface ISourceOffset {\n  generated: IPosition;\n  name: string;\n  original: IPosition;\n}\n\nfunction preprocessor() {\n  const errors: Errors = {};\n  const cache: Cache = {};\n  const offsets: Record<string, ISourceOffset[] | undefined> = {};\n\n  return {\n    code(input: string, filename: string) {\n      let result;\n\n      try {\n        result = transform(input, {\n          filename,\n        });\n\n        cache[filename] = undefined;\n        errors[filename] = undefined;\n        offsets[filename] = [];\n      } catch (e: unknown) {\n        cache[filename] = undefined;\n        offsets[filename] = undefined;\n        errors[filename] = e as Error;\n\n        // Ignore parse errors here\n        // We handle it separately\n        return '';\n      }\n\n      const { rules, replacements } = result;\n\n      if (!rules) {\n        return '';\n      }\n\n      // Construct a CSS-ish file from the unprocessed style rules\n      let generatedLineNumber = 1;\n      let cssText = Object.values(rules)\n        .map((rule) => {\n          const ruleText = `.${rule.className} {${rule.cssText}}`;\n\n          if (rule.start && 'line' in rule.start) {\n            offsets[filename]?.push({\n              generated: {\n                line: generatedLineNumber,\n                column: 1,\n              },\n              original: {\n                ...rule.start,\n              },\n              name: rule.displayName,\n            });\n\n            generatedLineNumber += 1;\n          }\n\n          generatedLineNumber += ruleText.split('\\n').length + 2;\n          return ruleText;\n        })\n        .join('\\n\\n');\n\n      cache[filename] = replacements;\n      offsets[filename] = offsets[filename]?.reverse();\n\n      console.log(cssText);\n\n      return cssText + '\\n';\n    },\n    result(result: LintResult, filename: string) {\n      const error = errors[filename];\n      const replacements = cache[filename];\n      const sourceMap = offsets[filename];\n\n      if (sourceMap) {\n        result.warnings = result.warnings.map((warning) => {\n          const offset = sourceMap.find(\n            (o) => o.generated.line <= warning.line\n          );\n          if (offset) {\n            warning.line += offset.original.line - offset.generated.line;\n          }\n\n          return warning;\n        });\n      }\n\n      if (error) {\n        // Babel adds this to the error message\n        const prefix = `${filename}: `;\n\n        let message = stripAnsi(\n          error.message.startsWith(prefix)\n            ? error.message.replace(prefix, '')\n            : error.message\n        );\n\n        let { loc } = error;\n\n        if (!loc) {\n          // If the error doesn't have location info, try to find it from the code frame\n          const line = message.split('\\n').find((l) => l.startsWith('>'));\n          const column = message.split('\\n').find((l) => l.includes('^'));\n\n          if (line && column) {\n            loc = {\n              line: Number(line.replace(/^> /, '').split('|')[0].trim()),\n              column: column.replace(/[^|]+\\|\\s/, '').length,\n            };\n          }\n        }\n\n        if (loc) {\n          // Strip the codeframe text if we have location of the error\n          // It's formatted badly by stylelint, so not very helpful\n          message = message.replace(/^>?\\s+\\d?\\s\\|.*$/gm, '').trim();\n        }\n\n        // eslint-disable-next-line no-param-reassign\n        result.errored = true;\n        result.warnings.push({\n          rule: error.code || error.name,\n          text: message,\n          line: loc ? loc.line : 0,\n          column: loc ? loc.column : 0,\n          severity: 'error',\n        });\n      }\n\n      if (replacements) {\n        replacements.forEach(({ original, length }) => {\n          // If the warnings contain stuff that's been replaced,\n          // Correct the line and column numbers to what's replaced\n          result.warnings.forEach((w) => {\n            /* eslint-disable no-param-reassign */\n            if (w.line === original.start.line) {\n              // If the error is on the same line where an interpolation started, we need to adjust the line and column numbers\n              // Because a replacement would have increased or decreased the column numbers\n              // If it's in the same line where interpolation ended, it would have been adjusted during replacement\n              if (w.column > original.start.column + length) {\n                // The error is from an item after the replacements\n                // So we need to adjust the column\n                w.column +=\n                  original.end.column - original.start.column + 1 - length;\n              } else if (\n                w.column >= original.start.column &&\n                w.column < original.start.column + length\n              ) {\n                // The linter will underline the whole word in the editor if column is in inside a word\n                // Set the column to the end, so it will underline the word inside the interpolation\n                // e.g. in `${colors.primary}`, `primary` will be underlined\n                w.column =\n                  original.start.line === original.end.line\n                    ? original.end.column - 1\n                    : original.start.column;\n              }\n            }\n          });\n        });\n      }\n\n      return result;\n    },\n  };\n}\n\nmodule.exports = preprocessor;\n"],"file":"preprocessor.js"}