import hasImport from './hasImport';

function getTemplateTypeByTag(t, path, localName, has) {
  const {
    tag
  } = path.node; // styled(Cmp)``

  if (t.isCallExpression(tag) && t.isIdentifier(tag.callee) && tag.arguments.length === 1 && tag.callee.name === localName && has(localName, ['@linaria/react', 'linaria/react'])) {
    const tagPath = path.get('tag');
    return {
      component: tagPath.get('arguments')[0]
    };
  } // styled.div``


  if (t.isMemberExpression(tag) && t.isIdentifier(tag.object) && t.isIdentifier(tag.property) && tag.object.name === localName && has(localName, ['@linaria/react', 'linaria/react'])) {
    return {
      component: {
        node: t.stringLiteral(tag.property.name)
      }
    };
  } // css``


  if (has('css', ['@linaria/core', 'linaria']) && t.isIdentifier(tag) && tag.name === 'css') {
    return 'css';
  } // css`` but atomic


  if (has('css', ['@linaria/atomic']) && t.isIdentifier(tag) && tag.name === 'css') {
    return 'atomic-css';
  }

  return null;
}

const cache = new WeakMap();
export default function getTemplateType({
  types: t
}, path, state, libResolver) {
  if (!cache.has(path)) {
    const localName = state.file.metadata.localName || 'styled';

    const has = (identifier, sources) => hasImport(t, path.scope, state.file.opts.filename, identifier, sources, libResolver);

    cache.set(path, getTemplateTypeByTag(t, path, localName, has));
  }

  return cache.get(path) ?? null;
}
//# sourceMappingURL=getTemplateType.js.map