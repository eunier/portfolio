{"version":3,"sources":["../../src/visitors/CollectDependencies.ts"],"names":["debug","generator","throwIfInvalid","ValueType","getTemplateType","hoist","babel","ex","Identifier","idPath","isReferencedIdentifier","binding","scope","getBinding","node","name","path","bindingPath","referencePaths","parent","isVariableDeclarator","initPath","get","isIdentifier","forEach","referencePath","replaceWith","types","identifier","traverse","CollectDependencies","state","options","libResolver","t","templateType","expressions","length","expressionValues","map","isExpression","buildCodeFrameError","code","result","evaluate","confident","value","kind","VALUE","isFunctionExpression","isArrowFunctionExpression","originalExNode","cloneNode","hoistedExNode","LAZY","originalEx","FUNCTION","expressionValue","component","push","queue","styled","undefined"],"mappings":"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","sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport type {\n  Expression,\n  Identifier as IdentifierNode,\n  TaggedTemplateExpression,\n  TSType,\n} from '@babel/types';\nimport type { NodePath } from '@babel/traverse';\nimport { debug } from '@linaria/logger';\nimport generator from '@babel/generator';\nimport throwIfInvalid from '../utils/throwIfInvalid';\nimport type { State, StrictOptions, ExpressionValue } from '../types';\nimport { ValueType } from '../types';\nimport getTemplateType from '../utils/getTemplateType';\nimport { Core } from '../babel';\n\n/**\n * Hoist the node and its dependencies to the highest scope possible\n */\nfunction hoist(babel: Core, ex: NodePath<Expression | null>) {\n  const Identifier = (idPath: NodePath<IdentifierNode>) => {\n    if (!idPath.isReferencedIdentifier()) {\n      return;\n    }\n    const binding = idPath.scope.getBinding(idPath.node.name);\n    if (!binding) return;\n    const { scope, path: bindingPath, referencePaths } = binding;\n    // parent here can be null or undefined in different versions of babel\n    if (!scope.parent) {\n      // It's a variable from global scope\n      return;\n    }\n\n    if (bindingPath.isVariableDeclarator()) {\n      const initPath = bindingPath.get('init') as NodePath<Expression | null>;\n      hoist(babel, initPath);\n      initPath.hoist(scope);\n      if (initPath.isIdentifier()) {\n        referencePaths.forEach((referencePath) => {\n          referencePath.replaceWith(babel.types.identifier(initPath.node.name));\n        });\n      }\n    }\n  };\n\n  if (ex.isIdentifier()) {\n    return Identifier(ex);\n  }\n\n  ex.traverse({\n    Identifier,\n  });\n}\n\nexport default function CollectDependencies(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: StrictOptions\n) {\n  const { libResolver } = options;\n  const { types: t } = babel;\n  const templateType = getTemplateType(babel, path, state, libResolver);\n  if (!templateType) {\n    return;\n  }\n  const expressions = path.get('quasi').get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression | TSType>) => {\n      if (!ex.isExpression()) {\n        throw ex.buildCodeFrameError(\n          `The expression '${generator(ex.node).code}' is not supported.`\n        );\n      }\n\n      const result = ex.evaluate();\n      if (result.confident) {\n        throwIfInvalid(result.value, ex);\n        return { kind: ValueType.VALUE, value: result.value };\n      }\n      if (\n        options.evaluate &&\n        !(t.isFunctionExpression(ex) || t.isArrowFunctionExpression(ex))\n      ) {\n        // save original expression that may be changed during hoisting\n        const originalExNode = t.cloneNode(ex.node);\n\n        hoist(babel, ex as NodePath<Expression | null>);\n\n        // save hoisted expression to be used to evaluation\n        const hoistedExNode = t.cloneNode(ex.node);\n\n        // get back original expression to the tree\n        ex.replaceWith(originalExNode);\n\n        return { kind: ValueType.LAZY, ex: hoistedExNode, originalEx: ex };\n      }\n\n      return { kind: ValueType.FUNCTION, ex };\n    }\n  );\n\n  debug(\n    'template-parse:evaluate-expressions',\n    expressionValues.map((expressionValue) =>\n      expressionValue.kind === ValueType.VALUE ? expressionValue.value : 'lazy'\n    )\n  );\n\n  if (\n    templateType !== 'css' &&\n    templateType !== 'atomic-css' &&\n    'name' in templateType.component.node\n  ) {\n    // It's not a real dependency.\n    // It can be simplified because we need just a className.\n    expressionValues.push({\n      // kind: ValueType.COMPONENT,\n      kind: ValueType.LAZY,\n      ex: templateType.component.node.name,\n      originalEx: templateType.component.node.name,\n    });\n  }\n\n  state.queue.push({\n    styled:\n      templateType !== 'css' && templateType !== 'atomic-css'\n        ? templateType\n        : undefined,\n    path,\n    expressionValues,\n  });\n}\n"],"file":"CollectDependencies.js"}