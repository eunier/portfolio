{"version":3,"sources":["../../src/visitors/GenerateClassNames.ts"],"names":["basename","dirname","relative","extname","sep","slugify","debug","toValidCSSIdentifier","getLinariaComment","getTemplateType","isSlugVar","GenerateClassNames","babel","path","state","options","types","t","templateType","expressions","get","length","index","slug","displayName","predefinedClassName","parent","findParent","p","isObjectProperty","isJSXOpeningElement","isVariableDeclarator","parentNode","node","key","name","value","toString","keyPath","getSource","isJSXIdentifier","isIdentifier","id","file","opts","filename","test","replace","buildCodeFrameError","charAt","toLowerCase","root","process","cwd","slice","ext","slugVars","hash","title","dir","split","pop","className","classNameSlug","Error","optionVariables","match","cnSlug","i","l","v","type","addComment"],"mappings":"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","sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it generates a slug that will be used as a CSS class for particular Template Expression,\n * and generates a display name for class or styled components.\n * It saves that meta data as comment above the template, to be later used in templateProcessor.\n */\n\nimport { basename, dirname, relative, extname, sep } from 'path';\nimport { slugify } from '@linaria/utils';\nimport type { ObjectProperty, TaggedTemplateExpression } from '@babel/types';\nimport type { NodePath } from '@babel/traverse';\nimport { debug } from '@linaria/logger';\nimport type { ClassNameSlugVars, State, StrictOptions } from '../types';\nimport toValidCSSIdentifier from '../utils/toValidCSSIdentifier';\nimport getLinariaComment from '../utils/getLinariaComment';\nimport getTemplateType from '../utils/getTemplateType';\nimport { Core } from '../babel';\nimport isSlugVar from '../utils/isSlugVar';\n\nexport default function GenerateClassNames(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: StrictOptions\n) {\n  const { types: t } = babel;\n  const templateType = getTemplateType(babel, path, state);\n  if (!templateType) {\n    return;\n  }\n\n  const expressions = path.get('quasi').get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  // Increment the index of the style we're processing\n  // This is used for slug generation to prevent collision\n  // Also used for display name if it couldn't be determined\n  state.index++;\n\n  let [, slug, displayName, predefinedClassName] = getLinariaComment(path);\n\n  const parent = path.findParent(\n    (p) =>\n      t.isObjectProperty(p) ||\n      t.isJSXOpeningElement(p) ||\n      t.isVariableDeclarator(p)\n  );\n\n  if (!displayName && parent) {\n    const parentNode = parent.node;\n    if (t.isObjectProperty(parentNode)) {\n      if ('name' in parentNode.key) {\n        displayName = parentNode.key.name;\n      } else if ('value' in parentNode.key) {\n        displayName = parentNode.key.value.toString();\n      } else {\n        const keyPath = (parent as NodePath<ObjectProperty>).get('key');\n        displayName = keyPath.getSource();\n      }\n    } else if (\n      t.isJSXOpeningElement(parentNode) &&\n      t.isJSXIdentifier(parentNode.name)\n    ) {\n      displayName = parentNode.name.name;\n    } else if (\n      t.isVariableDeclarator(parentNode) &&\n      t.isIdentifier(parentNode.id)\n    ) {\n      displayName = parentNode.id.name;\n    }\n  }\n\n  if (!displayName) {\n    // Try to derive the path from the filename\n    displayName = basename(state.file.opts.filename);\n\n    if (/^index\\.[a-z0-9]+$/.test(displayName)) {\n      // If the file name is 'index', better to get name from parent folder\n      displayName = basename(dirname(state.file.opts.filename));\n    }\n\n    // Remove the file extension\n    displayName = displayName.replace(/\\.[a-z0-9]+$/, '');\n\n    if (displayName) {\n      displayName += state.index;\n    } else {\n      throw path.buildCodeFrameError(\n        \"Couldn't determine a name for the component. Ensure that it's either:\\n\" +\n          '- Assigned to a variable\\n' +\n          '- Is an object property\\n' +\n          '- Is a prop in a JSX element\\n'\n      );\n    }\n  }\n\n  // Custom properties need to start with a letter, so we prefix the slug\n  // Also use append the index of the class to the filename for uniqueness in the file\n  slug =\n    slug ||\n    toValidCSSIdentifier(\n      `${displayName.charAt(0).toLowerCase()}${slugify(\n        `${relative(state.file.opts.root, state.file.opts.filename)}:${\n          state.index\n        }`\n      )}`\n    );\n\n  // Collect some useful replacement patterns from the filename\n  // Available variables for the square brackets used in `classNameSlug` options\n  const file = relative(process.cwd(), state.file.opts.filename).slice(1);\n  const ext = extname(file);\n  const slugVars: ClassNameSlugVars = {\n    hash: slug,\n    title: displayName,\n    file,\n    ext,\n    name: basename(file, ext),\n    dir: dirname(file).split(sep).pop() as string,\n  };\n\n  let className = predefinedClassName\n    ? predefinedClassName\n    : options.displayName\n    ? `${toValidCSSIdentifier(displayName!)}_${slug!}`\n    : slug!;\n\n  // The className can be defined by the user either as fn or a string\n  if (typeof options.classNameSlug === 'function') {\n    try {\n      className = toValidCSSIdentifier(\n        options.classNameSlug(slug, displayName, slugVars)\n      );\n    } catch {\n      throw new Error(`classNameSlug option must return a string`);\n    }\n  }\n\n  if (typeof options.classNameSlug === 'string') {\n    const { classNameSlug } = options;\n\n    // Variables that were used in the config for `classNameSlug`\n    const optionVariables = classNameSlug.match(/\\[.*?]/g) || [];\n    let cnSlug = classNameSlug;\n\n    for (let i = 0, l = optionVariables.length; i < l; i++) {\n      const v = optionVariables[i].slice(1, -1); // Remove the brackets around the variable name\n\n      // Replace the var if it key and value exist otherwise place an empty string\n      cnSlug = cnSlug.replace(\n        `[${v}]`,\n        isSlugVar(v, slugVars) ? slugVars[v] : ''\n      );\n    }\n\n    className = toValidCSSIdentifier(cnSlug);\n  }\n\n  const type =\n    templateType !== 'css' && templateType !== 'atomic-css'\n      ? 'styled'\n      : templateType;\n\n  debug(\n    `template-parse:generated-meta:${type}`,\n    `slug: ${slug}, displayName: ${displayName}, className: ${className}`\n  );\n\n  // Save evaluated slug and displayName for future usage in templateProcessor\n  path.addComment(\n    'leading',\n    `linaria ${type} ${slug} ${displayName} ${className}`\n  );\n}\n"],"file":"GenerateClassNames.js"}