{"version":3,"file":"collectTemplateDependencies.js","names":["generator","debug","ValueType","getSource","getTagProcessor","throwIfInvalid","hoist","babel","ex","Identifier","idPath","isReferencedIdentifier","binding","scope","getBinding","node","name","path","bindingPath","referencePaths","parent","isVariableDeclarator","initPath","get","isIdentifier","forEach","referencePath","replaceWith","types","identifier","traverse","findValuePath","undefined","collectTemplateDependencies","state","options","t","quasi","quasis","expressions","length","expressionValues","map","isExpression","buildCodeFrameError","code","result","evaluate","value","confident","valuePath","isTaggedTemplateExpression","context","asSelector","kind","VALUE","source","isFunctionExpression","isArrowFunctionExpression","originalExNode","cloneNode","hoistedExNode","LAZY","originalEx","FUNCTION","expressionValue"],"sources":["../../src/utils/collectTemplateDependencies.ts"],"sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport generator from '@babel/generator';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  Expression,\n  Identifier as IdentifierNode,\n  TaggedTemplateExpression,\n  TemplateElement,\n  TSType,\n} from '@babel/types';\n\nimport { debug } from '@linaria/logger';\n\nimport type { Core } from '../babel';\nimport type { StrictOptions, ExpressionValue, State } from '../types';\nimport { ValueType } from '../types';\n\nimport getSource from './getSource';\nimport getTagProcessor from './getTagProcessor';\nimport throwIfInvalid from './throwIfInvalid';\n\n/**\n * Hoist the node and its dependencies to the highest scope possible\n */\nfunction hoist(babel: Core, ex: NodePath<Expression | null>): void {\n  const Identifier = (idPath: NodePath<IdentifierNode>) => {\n    if (!idPath.isReferencedIdentifier()) {\n      return;\n    }\n    const binding = idPath.scope.getBinding(idPath.node.name);\n    if (!binding) return;\n    const { scope, path: bindingPath, referencePaths } = binding;\n    // parent here can be null or undefined in different versions of babel\n    if (!scope.parent) {\n      // It's a variable from global scope\n      return;\n    }\n\n    if (bindingPath.isVariableDeclarator()) {\n      const initPath = bindingPath.get('init') as NodePath<Expression | null>;\n      hoist(babel, initPath);\n      initPath.hoist(scope);\n      if (initPath.isIdentifier()) {\n        referencePaths.forEach((referencePath) => {\n          referencePath.replaceWith(babel.types.identifier(initPath.node.name));\n        });\n      }\n    }\n  };\n\n  if (ex.isIdentifier()) {\n    Identifier(ex);\n    return;\n  }\n\n  ex.traverse({\n    Identifier,\n  });\n}\n\nfunction findValuePath(\n  path: NodePath<Expression>\n): NodePath<Expression | null | undefined> | undefined {\n  if (!path.isIdentifier()) {\n    return undefined;\n  }\n\n  const binding = path.scope.getBinding(path.node.name);\n  if (binding?.path.isVariableDeclarator()) {\n    return binding.path.get('init');\n  }\n\n  return undefined;\n}\n\nexport default function collectTemplateDependencies(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: Pick<StrictOptions, 'classNameSlug' | 'displayName' | 'evaluate'>\n): [quasis: NodePath<TemplateElement>[], expressionValues: ExpressionValue[]] {\n  const { types: t } = babel;\n  const quasi = path.get('quasi');\n  const quasis = quasi.get('quasis');\n  const expressions = quasi.get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression | TSType>): ExpressionValue => {\n      if (!ex.isExpression()) {\n        throw ex.buildCodeFrameError(\n          `The expression '${generator(ex.node).code}' is not supported.`\n        );\n      }\n\n      const result = ex.evaluate();\n      let value: unknown;\n      if (result.confident) {\n        value = result.value;\n      } else {\n        // In some cases we can find a value of expression without evaluation\n        // If the value is a TaggedTemplateExpression, we can get class name for it\n        const valuePath = findValuePath(ex);\n        if (valuePath?.isTaggedTemplateExpression()) {\n          const context = getTagProcessor(valuePath, state, options);\n          if (context?.asSelector) {\n            return {\n              kind: ValueType.VALUE,\n              value: context.asSelector,\n              ex,\n              source: getSource(ex),\n            };\n          }\n        }\n      }\n\n      if (value !== undefined) {\n        throwIfInvalid(value, ex);\n        return {\n          kind: ValueType.VALUE,\n          value,\n          ex,\n          source: getSource(ex),\n        };\n      }\n\n      if (\n        options.evaluate &&\n        !(ex.isFunctionExpression() || ex.isArrowFunctionExpression())\n      ) {\n        // save original expression that may be changed during hoisting\n        const originalExNode = t.cloneNode(ex.node);\n\n        hoist(babel, ex as NodePath<Expression | null>);\n\n        // save hoisted expression to be used to evaluation\n        const hoistedExNode = t.cloneNode(ex.node);\n\n        // get back original expression to the tree\n        ex.replaceWith(originalExNode);\n\n        return {\n          kind: ValueType.LAZY,\n          ex: hoistedExNode,\n          originalEx: ex,\n          source: getSource(ex),\n        };\n      }\n\n      return { kind: ValueType.FUNCTION, ex, source: getSource(ex) };\n    }\n  );\n\n  debug(\n    'template-parse:evaluate-expressions',\n    expressionValues.map((expressionValue) =>\n      expressionValue.kind === ValueType.VALUE ? expressionValue.value : 'lazy'\n    )\n  );\n\n  return [quasis, expressionValues];\n}\n"],"mappings":"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"}