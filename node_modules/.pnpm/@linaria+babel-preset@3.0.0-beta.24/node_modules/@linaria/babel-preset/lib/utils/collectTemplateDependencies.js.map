{"version":3,"file":"collectTemplateDependencies.js","names":["hoist","babel","ex","Identifier","idPath","isReferencedIdentifier","binding","scope","getBinding","node","name","path","bindingPath","referencePaths","parent","isVariableDeclarator","initPath","get","isIdentifier","forEach","referencePath","replaceWith","types","identifier","traverse","findValuePath","undefined","collectTemplateDependencies","state","options","t","quasi","quasis","expressions","debug","length","expressionValues","map","isExpression","buildCodeFrameError","generator","code","result","evaluate","value","confident","valuePath","isTaggedTemplateExpression","context","getTagProcessor","asSelector","kind","ValueType","VALUE","source","getSource","throwIfInvalid","isFunctionExpression","isArrowFunctionExpression","originalExNode","cloneNode","hoistedExNode","LAZY","originalEx","FUNCTION","expressionValue"],"sources":["../../src/utils/collectTemplateDependencies.ts"],"sourcesContent":["/**\n * This file is a visitor that checks TaggedTemplateExpressions and look for Linaria css or styled templates.\n * For each template it makes a list of dependencies, try to evaluate expressions, and if it is not possible, mark them as lazy dependencies.\n */\n\nimport generator from '@babel/generator';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  Expression,\n  Identifier as IdentifierNode,\n  TaggedTemplateExpression,\n  TemplateElement,\n  TSType,\n} from '@babel/types';\n\nimport { debug } from '@linaria/logger';\n\nimport type { Core } from '../babel';\nimport type { StrictOptions, ExpressionValue, State } from '../types';\nimport { ValueType } from '../types';\n\nimport getSource from './getSource';\nimport getTagProcessor from './getTagProcessor';\nimport throwIfInvalid from './throwIfInvalid';\n\n/**\n * Hoist the node and its dependencies to the highest scope possible\n */\nfunction hoist(babel: Core, ex: NodePath<Expression | null>): void {\n  const Identifier = (idPath: NodePath<IdentifierNode>) => {\n    if (!idPath.isReferencedIdentifier()) {\n      return;\n    }\n    const binding = idPath.scope.getBinding(idPath.node.name);\n    if (!binding) return;\n    const { scope, path: bindingPath, referencePaths } = binding;\n    // parent here can be null or undefined in different versions of babel\n    if (!scope.parent) {\n      // It's a variable from global scope\n      return;\n    }\n\n    if (bindingPath.isVariableDeclarator()) {\n      const initPath = bindingPath.get('init') as NodePath<Expression | null>;\n      hoist(babel, initPath);\n      initPath.hoist(scope);\n      if (initPath.isIdentifier()) {\n        referencePaths.forEach((referencePath) => {\n          referencePath.replaceWith(babel.types.identifier(initPath.node.name));\n        });\n      }\n    }\n  };\n\n  if (ex.isIdentifier()) {\n    Identifier(ex);\n    return;\n  }\n\n  ex.traverse({\n    Identifier,\n  });\n}\n\nfunction findValuePath(\n  path: NodePath<Expression>\n): NodePath<Expression | null | undefined> | undefined {\n  if (!path.isIdentifier()) {\n    return undefined;\n  }\n\n  const binding = path.scope.getBinding(path.node.name);\n  if (binding?.path.isVariableDeclarator()) {\n    return binding.path.get('init');\n  }\n\n  return undefined;\n}\n\nexport default function collectTemplateDependencies(\n  babel: Core,\n  path: NodePath<TaggedTemplateExpression>,\n  state: State,\n  options: Pick<StrictOptions, 'classNameSlug' | 'displayName' | 'evaluate'>\n): [quasis: NodePath<TemplateElement>[], expressionValues: ExpressionValue[]] {\n  const { types: t } = babel;\n  const quasi = path.get('quasi');\n  const quasis = quasi.get('quasis');\n  const expressions = quasi.get('expressions');\n\n  debug('template-parse:identify-expressions', expressions.length);\n\n  const expressionValues: ExpressionValue[] = expressions.map(\n    (ex: NodePath<Expression | TSType>): ExpressionValue => {\n      if (!ex.isExpression()) {\n        throw ex.buildCodeFrameError(\n          `The expression '${generator(ex.node).code}' is not supported.`\n        );\n      }\n\n      const result = ex.evaluate();\n      let value: unknown;\n      if (result.confident) {\n        value = result.value;\n      } else {\n        // In some cases we can find a value of expression without evaluation\n        // If the value is a TaggedTemplateExpression, we can get class name for it\n        const valuePath = findValuePath(ex);\n        if (valuePath?.isTaggedTemplateExpression()) {\n          const context = getTagProcessor(valuePath, state, options);\n          if (context?.asSelector) {\n            return {\n              kind: ValueType.VALUE,\n              value: context.asSelector,\n              ex,\n              source: getSource(ex),\n            };\n          }\n        }\n      }\n\n      if (value !== undefined) {\n        throwIfInvalid(value, ex);\n        return {\n          kind: ValueType.VALUE,\n          value,\n          ex,\n          source: getSource(ex),\n        };\n      }\n\n      if (\n        options.evaluate &&\n        !(ex.isFunctionExpression() || ex.isArrowFunctionExpression())\n      ) {\n        // save original expression that may be changed during hoisting\n        const originalExNode = t.cloneNode(ex.node);\n\n        hoist(babel, ex as NodePath<Expression | null>);\n\n        // save hoisted expression to be used to evaluation\n        const hoistedExNode = t.cloneNode(ex.node);\n\n        // get back original expression to the tree\n        ex.replaceWith(originalExNode);\n\n        return {\n          kind: ValueType.LAZY,\n          ex: hoistedExNode,\n          originalEx: ex,\n          source: getSource(ex),\n        };\n      }\n\n      return { kind: ValueType.FUNCTION, ex, source: getSource(ex) };\n    }\n  );\n\n  debug(\n    'template-parse:evaluate-expressions',\n    expressionValues.map((expressionValue) =>\n      expressionValue.kind === ValueType.VALUE ? expressionValue.value : 'lazy'\n    )\n  );\n\n  return [quasis, expressionValues];\n}\n"],"mappings":"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"}