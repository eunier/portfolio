{"version":3,"file":"index.js","names":["isMemberExpression","path","Array","isArray","isLinariaPrevalExport","isExpressionStatement","get","isAssignmentExpression","left","object","property","isIdentifier","node","name","extractor","filename","options","text","only","transformOptions","buildOptions","presets","unshift","require","resolve","plugins","useESModules","code","transformSync","length","ast","parseSync","traverse","Program","body","idx","statements","RequirementsResolver","SequenceExpression","sequence","replaceWith","expressions","wrapped","reduce","acc","curr","t","blockStatement","String","raw","generator","join","stop"],"sources":["../src/index.ts"],"sourcesContent":["/**\n * This file is a main file of extractor evaluation strategy.\n * It finds __linariaPreval statements starting from the end of the program and\n * invoke RequirementsResolver to get parts of code that needs to be executed in order to evaluate the dependency.\n */\n\nimport { traverse, types as t, parseSync, transformSync } from '@babel/core';\nimport generator from '@babel/generator';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  ExpressionStatement,\n  MemberExpression,\n  Program,\n  SequenceExpression,\n} from '@babel/types';\n\nimport type { Evaluator } from '@linaria/babel-preset';\nimport { buildOptions } from '@linaria/babel-preset';\n\nimport RequirementsResolver from './RequirementsResolver';\n\nfunction isMemberExpression(\n  path: NodePath | NodePath[]\n): path is NodePath<MemberExpression> {\n  return !Array.isArray(path) && path.isMemberExpression();\n}\n\n// Checks that passed node is `exports.__linariaPreval = /* something */`\nfunction isLinariaPrevalExport(\n  path: NodePath\n): path is NodePath<ExpressionStatement> {\n  if (!path.isExpressionStatement()) {\n    return false;\n  }\n\n  if (\n    !(path as NodePath<ExpressionStatement>)\n      .get('expression')\n      .isAssignmentExpression()\n  ) {\n    return false;\n  }\n\n  const left = path.get('expression.left');\n\n  if (!isMemberExpression(left)) {\n    return false;\n  }\n\n  const object = left.get('object');\n  const property = left.get('property');\n  if (\n    Array.isArray(property) ||\n    !property.isIdentifier() ||\n    property.node.name !== '__linariaPreval'\n  ) {\n    return false;\n  }\n\n  return object.isIdentifier() && object.node.name === 'exports';\n}\n\nconst extractor: Evaluator = (filename, options, text, only = null) => {\n  const transformOptions = buildOptions(filename, options);\n  transformOptions.presets!.unshift([\n    require.resolve('@linaria/preeval'),\n    options,\n  ]);\n  transformOptions.plugins!.unshift([\n    require.resolve('@babel/plugin-transform-runtime'),\n    { useESModules: false },\n  ]);\n\n  // Expressions will be extracted only for __linariaPreval.\n  // In all other cases a code will be returned as is.\n  let { code } = transformSync(text, transformOptions)!;\n  if (!only || only.length !== 1 || only[0] !== '__linariaPreval') {\n    return [code!, null];\n  }\n  // We cannot just use `ast` that was returned by `transformSync`,\n  // because there is some kind of cache inside `traverse` which\n  // reuses `NodePath` with a wrong scope.\n  // There is probably a better solution, but I haven't found it yet.\n  const ast = parseSync(code!, { filename: `${filename}.preval` });\n  // First of all, let's find a __linariaPreval export\n  traverse(ast!, {\n    // We know that export has been added to the program body,\n    // so we don't need to traverse through the whole tree\n    Program(path: NodePath<Program>) {\n      const body = path.get('body');\n      // Highly likely it has been added in the end\n      for (let idx = body.length - 1; idx >= 0; idx--) {\n        if (isLinariaPrevalExport(body[idx])) {\n          // Here we are!\n          const statements = RequirementsResolver.resolve(\n            body[idx].get('expression.right')\n          );\n\n          // We only need to evaluate the last item in a sequence expression, e.g. (a, b, c)\n          body[idx].traverse({\n            SequenceExpression(sequence: NodePath<SequenceExpression>) {\n              sequence.replaceWith(\n                sequence.get('expressions')[\n                  sequence.node.expressions.length - 1\n                ]\n              );\n            },\n          });\n\n          // We'll wrap each code in a block to avoid collisions in variable names\n          const wrapped = statements.reduce(\n            (acc, curr) => t.blockStatement([curr, acc]),\n            t.blockStatement([body[idx].node])\n          );\n\n          // Generate a new code with extracted statements\n          code = [\n            // Use String.raw to preserve escapes such as '\\n' in the code\n            String.raw`${generator(wrapped).code}`,\n          ].join('\\n');\n          break;\n        }\n      }\n\n      path.stop();\n    },\n  });\n\n  return [code!, null];\n};\n\nexport default extractor;\n"],"mappings":"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"}