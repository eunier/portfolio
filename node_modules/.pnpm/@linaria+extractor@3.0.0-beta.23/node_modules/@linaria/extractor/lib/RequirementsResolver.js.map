{"version":3,"file":"RequirementsResolver.js","names":["RequirementsResolver","resolve","path","resolver","Array","isArray","forEach","p","statements","requirements","isAdded","some","req","parentPath","resolveBinding","binding","result","startPosition","node","start","kind","isImportSpecifier","isImportDeclaration","t","importDeclaration","source","decl","isVariableDeclarator","isSequenceExpression","init","variableDeclarator","id","expressions","length","variableDeclaration","Set","push","resolveIdentifier","scope","getBinding","name","isReferenced","set","isIdentifier","add","traverse","Identifier","zeroDeps","rest","reduce","acc","size","Error","map","reqs","r","delete","sort","a","b"],"sources":["../src/RequirementsResolver.ts"],"sourcesContent":["/**\n * This file is used to extract statements required to evaluate dependencies.\n * Starting from the exports.__linariaPreval passed as argument to static method on class RequirementsResolver,\n * it recursively extracts paths that contains identifiers that are needed to evaluate the dependency.\n */\n\nimport { types as t } from '@babel/core';\nimport type { Binding, NodePath } from '@babel/traverse';\nimport type {\n  Identifier,\n  Node,\n  Statement,\n  VariableDeclarator,\n} from '@babel/types';\n\ntype Requirement = {\n  result: Statement;\n  path: NodePath<Node>;\n  requirements: Set<NodePath>;\n};\n\nexport default class RequirementsResolver {\n  public static resolve(path: NodePath<Node> | NodePath<Node>[]): Statement[] {\n    const resolver = new RequirementsResolver();\n    if (Array.isArray(path)) {\n      path.forEach((p) => this.resolve(p));\n    } else {\n      resolver.resolve(path);\n    }\n\n    return resolver.statements;\n  }\n\n  private requirements: Requirement[] = [];\n\n  /**\n   * Checks that specified node or one of its ancestors is already added\n   */\n  private isAdded(path: NodePath<Node>): boolean {\n    if (this.requirements.some((req) => req.path === path)) {\n      return true;\n    }\n\n    if (path.parentPath) {\n      return this.isAdded(path.parentPath);\n    }\n\n    return false;\n  }\n\n  /**\n   * Makes a declaration statement, finds dependencies\n   * and adds all of it to the list of requirements.\n   */\n  private resolveBinding(binding: Binding) {\n    let result: Statement;\n    const startPosition = binding.path.node.start;\n\n    switch (binding.kind) {\n      case 'module':\n        if (\n          binding.path.isImportSpecifier() &&\n          binding.path.parentPath.isImportDeclaration()\n        ) {\n          result = t.importDeclaration(\n            [binding.path.node],\n            binding.path.parentPath.node.source\n          );\n        } else {\n          result = binding.path.parentPath?.node as Statement;\n        }\n        break;\n      case 'const':\n      case 'let':\n      case 'var': {\n        let decl = (binding.path as NodePath<VariableDeclarator>).node;\n        if (\n          binding.path.isVariableDeclarator() &&\n          t.isSequenceExpression(binding.path.node.init)\n        ) {\n          // Replace SequenceExpressions (expr1, expr2, expr3, ...) with the last one\n          decl = t.variableDeclarator(\n            binding.path.node.id,\n            binding.path.node.init.expressions[\n              binding.path.node.init.expressions.length - 1\n            ]\n          );\n        }\n\n        result = t.variableDeclaration(binding.kind, [decl]);\n        break;\n      }\n      default:\n        result = binding.path.node as Statement;\n        break;\n    }\n    // result may be newly created node that not have start/end/loc info\n    // which is needed to sort statements\n    result.start = startPosition;\n\n    const req: Requirement = {\n      result,\n      path: binding.path,\n      requirements: new Set(),\n    };\n\n    this.requirements.push(req);\n\n    req.requirements = this.resolve(binding.path);\n  }\n\n  /**\n   * Checks that a specified identifier has a binding and tries to resolve it\n   * @return `Binding` or null if there is no binding, or it is already added, or it has useless type\n   */\n  private resolveIdentifier(path: NodePath<Identifier>): Binding | null {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (\n      path.isReferenced() &&\n      binding &&\n      !this.isAdded(binding.path) &&\n      (binding.kind as unknown) !== 'param'\n    ) {\n      this.resolveBinding(binding);\n      return binding;\n    }\n\n    return null;\n  }\n\n  /**\n   * Finds all identifiers in a specified path, finds all related bindings\n   * and recursively calls `resolve` for each of them.\n   * @return `Set` with related bindings\n   */\n  private resolve(path: NodePath<Node>): Set<NodePath> {\n    const set = new Set<NodePath>();\n    if (path.isIdentifier()) {\n      const binding = this.resolveIdentifier(path);\n      if (binding !== null) {\n        set.add(binding.path);\n      }\n\n      return set;\n    }\n\n    path.traverse({\n      Identifier: (p) => {\n        const binding = this.resolveIdentifier(p);\n        if (binding !== null) {\n          set.add(binding.path);\n        }\n      },\n    });\n\n    return set;\n  }\n\n  /**\n   * Returns sorted list of required statements\n   */\n  private get statements(): Statement[] {\n    const statements: Statement[] = [];\n    let { requirements } = this;\n    while (requirements.length > 0) {\n      // On each step, we add to the result list only that statements\n      // which don't have any dependencies (`zeroDeps`)\n      const [zeroDeps, rest] = requirements.reduce(\n        (acc, req) => {\n          if (req.requirements.size === 0) {\n            acc[0].push(req);\n          } else {\n            acc[1].push(req);\n          }\n\n          return acc;\n        },\n        [[], []] as [Requirement[], Requirement[]]\n      );\n\n      if (zeroDeps.length === 0) {\n        // That means that we are in the endless loop.\n        // I don't know how it's possible, but if it's ever happened, we at least would be notified.\n        throw new Error('Circular dependency');\n      }\n\n      statements.push(...zeroDeps.map((req) => req.result));\n      // Let's remove already added statements from the requirements of the rest of the list.\n      requirements = rest.map((req) => {\n        const reqs = new Set(req.requirements);\n        zeroDeps.forEach((r) => reqs.delete(r.path));\n        return {\n          ...req,\n          requirements: reqs,\n        };\n      });\n    }\n\n    // preserve original statements order, but reversed\n    statements.sort((a, b) => {\n      if (a.start && b.start) {\n        return b.start - a.start;\n      }\n      return 0;\n    });\n\n    return statements;\n  }\n}\n"],"mappings":"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"}