{"version":3,"file":"index.js","names":["traverse","types","t","parseSync","transformSync","generator","buildOptions","RequirementsResolver","isMemberExpression","path","Array","isArray","isLinariaPrevalExport","isExpressionStatement","get","isAssignmentExpression","left","object","property","isIdentifier","node","name","extractor","filename","options","text","only","transformOptions","presets","unshift","require","resolve","plugins","useESModules","code","length","ast","Program","body","idx","statements","SequenceExpression","sequence","replaceWith","expressions","wrapped","reduce","acc","curr","blockStatement","String","raw","join","stop"],"sources":["../src/index.ts"],"sourcesContent":["/**\n * This file is a main file of extractor evaluation strategy.\n * It finds __linariaPreval statements starting from the end of the program and\n * invoke RequirementsResolver to get parts of code that needs to be executed in order to evaluate the dependency.\n */\n\nimport { traverse, types as t, parseSync, transformSync } from '@babel/core';\nimport generator from '@babel/generator';\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  ExpressionStatement,\n  MemberExpression,\n  Program,\n  SequenceExpression,\n} from '@babel/types';\n\nimport type { Evaluator } from '@linaria/babel-preset';\nimport { buildOptions } from '@linaria/babel-preset';\n\nimport RequirementsResolver from './RequirementsResolver';\n\nfunction isMemberExpression(\n  path: NodePath | NodePath[]\n): path is NodePath<MemberExpression> {\n  return !Array.isArray(path) && path.isMemberExpression();\n}\n\n// Checks that passed node is `exports.__linariaPreval = /* something */`\nfunction isLinariaPrevalExport(\n  path: NodePath\n): path is NodePath<ExpressionStatement> {\n  if (!path.isExpressionStatement()) {\n    return false;\n  }\n\n  if (\n    !(path as NodePath<ExpressionStatement>)\n      .get('expression')\n      .isAssignmentExpression()\n  ) {\n    return false;\n  }\n\n  const left = path.get('expression.left');\n\n  if (!isMemberExpression(left)) {\n    return false;\n  }\n\n  const object = left.get('object');\n  const property = left.get('property');\n  if (\n    Array.isArray(property) ||\n    !property.isIdentifier() ||\n    property.node.name !== '__linariaPreval'\n  ) {\n    return false;\n  }\n\n  return object.isIdentifier() && object.node.name === 'exports';\n}\n\nconst extractor: Evaluator = (filename, options, text, only = null) => {\n  const transformOptions = buildOptions(filename, options);\n  transformOptions.presets!.unshift([\n    require.resolve('@linaria/preeval'),\n    options,\n  ]);\n  transformOptions.plugins!.unshift([\n    require.resolve('@babel/plugin-transform-runtime'),\n    { useESModules: false },\n  ]);\n\n  // Expressions will be extracted only for __linariaPreval.\n  // In all other cases a code will be returned as is.\n  let { code } = transformSync(text, transformOptions)!;\n  if (!only || only.length !== 1 || only[0] !== '__linariaPreval') {\n    return [code!, null];\n  }\n  // We cannot just use `ast` that was returned by `transformSync`,\n  // because there is some kind of cache inside `traverse` which\n  // reuses `NodePath` with a wrong scope.\n  // There is probably a better solution, but I haven't found it yet.\n  const ast = parseSync(code!, { filename: `${filename}.preval` });\n  // First of all, let's find a __linariaPreval export\n  traverse(ast!, {\n    // We know that export has been added to the program body,\n    // so we don't need to traverse through the whole tree\n    Program(path: NodePath<Program>) {\n      const body = path.get('body');\n      // Highly likely it has been added in the end\n      for (let idx = body.length - 1; idx >= 0; idx--) {\n        if (isLinariaPrevalExport(body[idx])) {\n          // Here we are!\n          const statements = RequirementsResolver.resolve(\n            body[idx].get('expression.right')\n          );\n\n          // We only need to evaluate the last item in a sequence expression, e.g. (a, b, c)\n          body[idx].traverse({\n            SequenceExpression(sequence: NodePath<SequenceExpression>) {\n              sequence.replaceWith(\n                sequence.get('expressions')[\n                  sequence.node.expressions.length - 1\n                ]\n              );\n            },\n          });\n\n          // We'll wrap each code in a block to avoid collisions in variable names\n          const wrapped = statements.reduce(\n            (acc, curr) => t.blockStatement([curr, acc]),\n            t.blockStatement([body[idx].node])\n          );\n\n          // Generate a new code with extracted statements\n          code = [\n            // Use String.raw to preserve escapes such as '\\n' in the code\n            String.raw`${generator(wrapped).code}`,\n          ].join('\\n');\n          break;\n        }\n      }\n\n      path.stop();\n    },\n  });\n\n  return [code!, null];\n};\n\nexport default extractor;\n"],"mappings":"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"}