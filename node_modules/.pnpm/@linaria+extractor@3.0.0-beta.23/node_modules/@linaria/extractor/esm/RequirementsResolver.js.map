{"version":3,"file":"RequirementsResolver.js","names":["types","t","RequirementsResolver","resolve","path","resolver","Array","isArray","forEach","p","statements","requirements","isAdded","some","req","parentPath","resolveBinding","binding","result","startPosition","node","start","kind","isImportSpecifier","isImportDeclaration","importDeclaration","source","decl","isVariableDeclarator","isSequenceExpression","init","variableDeclarator","id","expressions","length","variableDeclaration","Set","push","resolveIdentifier","scope","getBinding","name","isReferenced","set","isIdentifier","add","traverse","Identifier","zeroDeps","rest","reduce","acc","size","Error","map","reqs","r","delete","sort","a","b"],"sources":["../src/RequirementsResolver.ts"],"sourcesContent":["/**\n * This file is used to extract statements required to evaluate dependencies.\n * Starting from the exports.__linariaPreval passed as argument to static method on class RequirementsResolver,\n * it recursively extracts paths that contains identifiers that are needed to evaluate the dependency.\n */\n\nimport { types as t } from '@babel/core';\nimport type { Binding, NodePath } from '@babel/traverse';\nimport type {\n  Identifier,\n  Node,\n  Statement,\n  VariableDeclarator,\n} from '@babel/types';\n\ntype Requirement = {\n  result: Statement;\n  path: NodePath<Node>;\n  requirements: Set<NodePath>;\n};\n\nexport default class RequirementsResolver {\n  public static resolve(path: NodePath<Node> | NodePath<Node>[]): Statement[] {\n    const resolver = new RequirementsResolver();\n    if (Array.isArray(path)) {\n      path.forEach((p) => this.resolve(p));\n    } else {\n      resolver.resolve(path);\n    }\n\n    return resolver.statements;\n  }\n\n  private requirements: Requirement[] = [];\n\n  /**\n   * Checks that specified node or one of its ancestors is already added\n   */\n  private isAdded(path: NodePath<Node>): boolean {\n    if (this.requirements.some((req) => req.path === path)) {\n      return true;\n    }\n\n    if (path.parentPath) {\n      return this.isAdded(path.parentPath);\n    }\n\n    return false;\n  }\n\n  /**\n   * Makes a declaration statement, finds dependencies\n   * and adds all of it to the list of requirements.\n   */\n  private resolveBinding(binding: Binding) {\n    let result: Statement;\n    const startPosition = binding.path.node.start;\n\n    switch (binding.kind) {\n      case 'module':\n        if (\n          binding.path.isImportSpecifier() &&\n          binding.path.parentPath.isImportDeclaration()\n        ) {\n          result = t.importDeclaration(\n            [binding.path.node],\n            binding.path.parentPath.node.source\n          );\n        } else {\n          result = binding.path.parentPath?.node as Statement;\n        }\n        break;\n      case 'const':\n      case 'let':\n      case 'var': {\n        let decl = (binding.path as NodePath<VariableDeclarator>).node;\n        if (\n          binding.path.isVariableDeclarator() &&\n          t.isSequenceExpression(binding.path.node.init)\n        ) {\n          // Replace SequenceExpressions (expr1, expr2, expr3, ...) with the last one\n          decl = t.variableDeclarator(\n            binding.path.node.id,\n            binding.path.node.init.expressions[\n              binding.path.node.init.expressions.length - 1\n            ]\n          );\n        }\n\n        result = t.variableDeclaration(binding.kind, [decl]);\n        break;\n      }\n      default:\n        result = binding.path.node as Statement;\n        break;\n    }\n    // result may be newly created node that not have start/end/loc info\n    // which is needed to sort statements\n    result.start = startPosition;\n\n    const req: Requirement = {\n      result,\n      path: binding.path,\n      requirements: new Set(),\n    };\n\n    this.requirements.push(req);\n\n    req.requirements = this.resolve(binding.path);\n  }\n\n  /**\n   * Checks that a specified identifier has a binding and tries to resolve it\n   * @return `Binding` or null if there is no binding, or it is already added, or it has useless type\n   */\n  private resolveIdentifier(path: NodePath<Identifier>): Binding | null {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (\n      path.isReferenced() &&\n      binding &&\n      !this.isAdded(binding.path) &&\n      (binding.kind as unknown) !== 'param'\n    ) {\n      this.resolveBinding(binding);\n      return binding;\n    }\n\n    return null;\n  }\n\n  /**\n   * Finds all identifiers in a specified path, finds all related bindings\n   * and recursively calls `resolve` for each of them.\n   * @return `Set` with related bindings\n   */\n  private resolve(path: NodePath<Node>): Set<NodePath> {\n    const set = new Set<NodePath>();\n    if (path.isIdentifier()) {\n      const binding = this.resolveIdentifier(path);\n      if (binding !== null) {\n        set.add(binding.path);\n      }\n\n      return set;\n    }\n\n    path.traverse({\n      Identifier: (p) => {\n        const binding = this.resolveIdentifier(p);\n        if (binding !== null) {\n          set.add(binding.path);\n        }\n      },\n    });\n\n    return set;\n  }\n\n  /**\n   * Returns sorted list of required statements\n   */\n  private get statements(): Statement[] {\n    const statements: Statement[] = [];\n    let { requirements } = this;\n    while (requirements.length > 0) {\n      // On each step, we add to the result list only that statements\n      // which don't have any dependencies (`zeroDeps`)\n      const [zeroDeps, rest] = requirements.reduce(\n        (acc, req) => {\n          if (req.requirements.size === 0) {\n            acc[0].push(req);\n          } else {\n            acc[1].push(req);\n          }\n\n          return acc;\n        },\n        [[], []] as [Requirement[], Requirement[]]\n      );\n\n      if (zeroDeps.length === 0) {\n        // That means that we are in the endless loop.\n        // I don't know how it's possible, but if it's ever happened, we at least would be notified.\n        throw new Error('Circular dependency');\n      }\n\n      statements.push(...zeroDeps.map((req) => req.result));\n      // Let's remove already added statements from the requirements of the rest of the list.\n      requirements = rest.map((req) => {\n        const reqs = new Set(req.requirements);\n        zeroDeps.forEach((r) => reqs.delete(r.path));\n        return {\n          ...req,\n          requirements: reqs,\n        };\n      });\n    }\n\n    // preserve original statements order, but reversed\n    statements.sort((a, b) => {\n      if (a.start && b.start) {\n        return b.start - a.start;\n      }\n      return 0;\n    });\n\n    return statements;\n  }\n}\n"],"mappings":"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"}